"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultFiles = exports.RokuDeploy = void 0;
const path = require("path");
const _fsExtra = require("fs-extra");
const r = require("postman-request");
const request = r;
const JSZip = require("jszip");
const dateformat = require("dateformat");
const errors = require("./Errors");
const isGlob = require("is-glob");
const picomatch = require("picomatch");
const xml2js = require("xml2js");
const jsonc_parser_1 = require("jsonc-parser");
const util_1 = require("./util");
const Logger_1 = require("./Logger");
const tempDir = require("temp-dir");
const dayjs = require("dayjs");
const lodash = require("lodash");
class RokuDeploy {
    constructor() {
        //store the import on the class to make testing easier
        this.fsExtra = _fsExtra;
        this.screenshotDir = path.join(tempDir, '/roku-deploy/screenshots/');
        this.logger = new Logger_1.Logger();
    }
    /**
     * Copies all of the referenced files to the staging folder
     * @param options
     */
    async prepublishToStaging(options) {
        options = this.getOptions(options);
        //clean the staging directory
        await this.fsExtra.remove(options.stagingDir);
        //make sure the staging folder exists
        await this.fsExtra.ensureDir(options.stagingDir);
        await this.copyToStaging(options.files, options.stagingDir, options.rootDir);
        return options.stagingDir;
    }
    /**
     * Given an array of `FilesType`, normalize them each into a `StandardizedFileEntry`.
     * Each entry in the array or inner `src` array will be extracted out into its own object.
     * This makes it easier to reason about later on in the process.
     * @param files
     */
    normalizeFilesArray(files) {
        const result = [];
        for (let i = 0; i < files.length; i++) {
            let entry = files[i];
            //skip falsey and blank entries
            if (!entry) {
                continue;
                //string entries
            }
            else if (typeof entry === 'string') {
                result.push(entry);
                //objects with src: (string | string[])
            }
            else if ('src' in entry) {
                //validate dest
                if (entry.dest !== undefined && entry.dest !== null && typeof entry.dest !== 'string') {
                    throw new Error(`Invalid type for "dest" at index ${i} of files array`);
                }
                //objects with src: string
                if (typeof entry.src === 'string') {
                    result.push({
                        src: util_1.util.standardizePath(entry.src),
                        dest: util_1.util.standardizePath(entry.dest)
                    });
                    //objects with src:string[]
                }
                else if ('src' in entry && Array.isArray(entry.src)) {
                    //create a distinct entry for each item in the src array
                    for (let srcEntry of entry.src) {
                        result.push({
                            src: util_1.util.standardizePath(srcEntry),
                            dest: util_1.util.standardizePath(entry.dest)
                        });
                    }
                }
                else {
                    throw new Error(`Invalid type for "src" at index ${i} of files array`);
                }
            }
            else {
                throw new Error(`Invalid entry at index ${i} in files array`);
            }
        }
        return result;
    }
    /**
     * Given an already-populated staging folder, create a zip archive of it and copy it to the output folder
     * @param options
     */
    async zipPackage(options) {
        options = this.getOptions(options);
        //make sure the output folder exists
        await this.fsExtra.ensureDir(options.outDir);
        let zipFilePath = this.getOutputZipFilePath(options);
        //ensure the manifest file exists in the staging folder
        if (!await util_1.util.fileExistsCaseInsensitive(`${options.stagingDir}/manifest`)) {
            throw new Error(`Cannot zip package: missing manifest file in "${options.stagingDir}"`);
        }
        //create a zip of the staging folder
        await this.zipFolder(options.stagingDir, zipFilePath);
        //delete the staging folder unless told to retain it.
        if (options.retainStagingDir !== true) {
            await this.fsExtra.remove(options.stagingDir);
        }
    }
    /**
     * Create a zip folder containing all of the specified roku project files.
     * @param options
     */
    async createPackage(options, beforeZipCallback) {
        options = this.getOptions(options);
        await this.prepublishToStaging(options);
        let manifestPath = util_1.util.standardizePath(`${options.stagingDir}/manifest`);
        let parsedManifest = await this.parseManifest(manifestPath);
        if (options.incrementBuildNumber) {
            let timestamp = dateformat(new Date(), 'yymmddHHMM');
            parsedManifest.build_version = timestamp; //eslint-disable-line camelcase
            await this.fsExtra.outputFile(manifestPath, this.stringifyManifest(parsedManifest));
        }
        if (beforeZipCallback) {
            let info = {
                manifestData: parsedManifest,
                stagingFolderPath: options.stagingDir,
                stagingDir: options.stagingDir
            };
            await Promise.resolve(beforeZipCallback(info));
        }
        await this.zipPackage(options);
    }
    /**
     * Given a root directory, normalize it to a full path.
     * Fall back to cwd if not specified
     * @param rootDir
     */
    normalizeRootDir(rootDir) {
        if (!rootDir || (typeof rootDir === 'string' && rootDir.trim().length === 0)) {
            return process.cwd();
        }
        else {
            return path.resolve(rootDir);
        }
    }
    /**
    * Get all file paths for the specified options
    * @param files
    * @param rootFolderPath - the absolute path to the root dir where relative files entries are relative to
    */
    async getFilePaths(files, rootDir) {
        //if the rootDir isn't absolute, convert it to absolute using the standard options flow
        if (path.isAbsolute(rootDir) === false) {
            rootDir = this.getOptions({ rootDir: rootDir }).rootDir;
        }
        const entries = this.normalizeFilesArray(files);
        const srcPathsByIndex = await util_1.util.globAllByIndex(entries.map(x => {
            return typeof x === 'string' ? x : x.src;
        }), rootDir);
        /**
         * Result indexed by the dest path
         */
        let result = new Map();
        //compute `dest` path for every file
        for (let i = 0; i < srcPathsByIndex.length; i++) {
            const srcPaths = srcPathsByIndex[i];
            const entry = entries[i];
            if (srcPaths) {
                for (let srcPath of srcPaths) {
                    srcPath = util_1.util.standardizePath(srcPath);
                    const dest = this.computeFileDestPath(srcPath, entry, rootDir);
                    //the last file with this `dest` will win, so just replace any existing entry with this one.
                    result.set(dest, {
                        src: srcPath,
                        dest: dest
                    });
                }
            }
        }
        return [...result.values()];
    }
    /**
     * Given a full path to a file, determine its dest path
     * @param srcPath the absolute path to the file. This MUST be a file path, and it is not verified to exist on the filesystem
     * @param files the files array
     * @param rootDir the absolute path to the root dir
     * @param skipMatch - skip running the minimatch process (i.e. assume the file is a match
     * @returns the RELATIVE path to the dest location for the file.
     */
    getDestPath(srcPathAbsolute, files, rootDir, skipMatch = false) {
        srcPathAbsolute = util_1.util.standardizePath(srcPathAbsolute);
        rootDir = rootDir.replace(/\\+/g, '/');
        const entries = this.normalizeFilesArray(files);
        function makeGlobAbsolute(pattern) {
            return path.resolve(path.posix.join(rootDir, 
            //remove leading exclamation point if pattern is negated
            pattern
            //coerce all slashes to forward
            )).replace(/\\/g, '/');
        }
        let result;
        //add the file into every matching cache bucket
        for (let entry of entries) {
            const pattern = (typeof entry === 'string' ? entry : entry.src);
            //filter previous paths
            if (pattern.startsWith('!')) {
                const keepFile = picomatch('!' + makeGlobAbsolute(pattern.replace(/^!/, '')));
                if (!keepFile(srcPathAbsolute)) {
                    result = undefined;
                }
            }
            else {
                const keepFile = picomatch(makeGlobAbsolute(pattern));
                if (keepFile(srcPathAbsolute)) {
                    try {
                        result = this.computeFileDestPath(srcPathAbsolute, entry, util_1.util.standardizePath(rootDir));
                    }
                    catch (_a) {
                        //ignore errors...the file just has no dest path
                    }
                }
            }
        }
        return result;
    }
    /**
     * Compute the `dest` path. This accounts for magic globstars in the pattern,
     * as well as relative paths based on the dest. This is only used internally.
     * @param src an absolute, normalized path for a file
     * @param dest the `dest` entry for this file. If omitted, files will derive their paths relative to rootDir.
     * @param pattern the glob pattern originally used to find this file
     * @param rootDir absolute normalized path to the rootDir
     */
    computeFileDestPath(srcPath, entry, rootDir) {
        var _a;
        let result;
        let globstarIdx;
        //files under rootDir with no specified dest
        if (typeof entry === 'string') {
            if (util_1.util.isParentOfPath(rootDir, srcPath, false)) {
                //files that are actually relative to rootDir
                result = util_1.util.stringReplaceInsensitive(srcPath, rootDir, '');
            }
            else {
                // result = util.stringReplaceInsensitive(srcPath, rootDir, '');
                throw new Error('Cannot reference a file outside of rootDir when using a top-level string. Please use a src;des; object instead');
            }
            //non-glob-pattern explicit file reference
        }
        else if (!isGlob(entry.src.replace(/\\/g, '/'), { strict: false })) {
            let isEntrySrcAbsolute = path.isAbsolute(entry.src);
            let entrySrcPathAbsolute = isEntrySrcAbsolute ? entry.src : util_1.util.standardizePath(`${rootDir}/${entry.src}`);
            let isSrcChildOfRootDir = util_1.util.isParentOfPath(rootDir, entrySrcPathAbsolute, false);
            let fileNameAndExtension = path.basename(entrySrcPathAbsolute);
            //no dest
            if (entry.dest === null || entry.dest === undefined) {
                //no dest, absolute path or file outside of rootDir
                if (isEntrySrcAbsolute || isSrcChildOfRootDir === false) {
                    //copy file to root of staging folder
                    result = fileNameAndExtension;
                    //no dest, relative path, lives INSIDE rootDir
                }
                else {
                    //copy relative file structure to root of staging folder
                    let srcPathRelative = util_1.util.stringReplaceInsensitive(entrySrcPathAbsolute, rootDir, '');
                    result = srcPathRelative;
                }
                //assume entry.dest is the relative path to the folder AND file if applicable
            }
            else if (entry.dest === '') {
                result = fileNameAndExtension;
            }
            else {
                result = entry.dest;
            }
            //has a globstar
        }
        else if ((globstarIdx = entry.src.indexOf('**')) > -1) {
            const rootGlobstarPath = path.resolve(rootDir, entry.src.substring(0, globstarIdx)) + path.sep;
            const srcPathRelative = util_1.util.stringReplaceInsensitive(srcPath, rootGlobstarPath, '');
            if (entry.dest) {
                result = `${entry.dest}/${srcPathRelative}`;
            }
            else {
                result = srcPathRelative;
            }
            //`pattern` is some other glob magic
        }
        else {
            const fileNameAndExtension = path.basename(srcPath);
            result = util_1.util.standardizePath(`${(_a = entry.dest) !== null && _a !== void 0 ? _a : ''}/${fileNameAndExtension}`);
        }
        result = util_1.util.standardizePath(
        //remove leading slashes
        result.replace(/^[\/\\]+/, ''));
        return result;
    }
    /**
     * Copy all of the files to the staging directory
     * @param fileGlobs
     * @param stagingPath
     */
    async copyToStaging(files, stagingPath, rootDir) {
        if (!stagingPath) {
            throw new Error('stagingPath is required');
        }
        if (!rootDir) {
            throw new Error('rootDir is required');
        }
        if (!await this.fsExtra.pathExists(rootDir)) {
            throw new Error(`rootDir does not exist at "${rootDir}"`);
        }
        let fileObjects = await this.getFilePaths(files, rootDir);
        //copy all of the files
        await Promise.all(fileObjects.map(async (fileObject) => {
            let destFilePath = util_1.util.standardizePath(`${stagingPath}/${fileObject.dest}`);
            //make sure the containing folder exists
            await this.fsExtra.ensureDir(path.dirname(destFilePath));
            //sometimes the copyfile action fails due to race conditions (normally to poorly constructed src;dest; objects with duplicate files in them
            await util_1.util.tryRepeatAsync(async () => {
                //copy the src item using the filesystem
                await this.fsExtra.copy(fileObject.src, destFilePath, {
                    //copy the actual files that symlinks point to, not the symlinks themselves
                    dereference: true
                });
            }, 10);
        }));
    }
    generateBaseRequestOptions(requestPath, options, formData = {}) {
        options = this.getOptions(options);
        let url = `http://${options.host}:${options.packagePort}/${requestPath}`;
        let baseRequestOptions = {
            url: url,
            timeout: options.timeout,
            auth: {
                user: options.username,
                pass: options.password,
                sendImmediately: false
            },
            formData: formData,
            agentOptions: { 'keepAlive': false }
        };
        return baseRequestOptions;
    }
    /**
     * Simulate pressing the home button on the remote for this roku.
     * This makes the roku return to the home screen
     * @param host - the host
     * @param port - the port that should be used for the request. defaults to 8060
     * @param timeout - request timeout duration in milliseconds. defaults to 150000
     */
    async pressHomeButton(host, port, timeout) {
        let options = this.getOptions();
        port = port ? port : options.remotePort;
        timeout = timeout ? timeout : options.timeout;
        // press the home button to return to the main screen
        return this.doPostRequest({
            url: `http://${host}:${port}/keypress/Home`,
            timeout: timeout
        }, false);
    }
    /**
     * Publish a pre-existing packaged zip file to a remote Roku.
     * @param options
     */
    async publish(options) {
        var _a, _b, _c, _d;
        options = this.getOptions(options);
        if (!options.host) {
            throw new errors.MissingRequiredOptionError('must specify the host for the Roku device');
        }
        //make sure the outDir exists
        await this.fsExtra.ensureDir(options.outDir);
        let zipFilePath = this.getOutputZipFilePath(options);
        let readStream;
        try {
            if ((await this.fsExtra.pathExists(zipFilePath)) === false) {
                throw new Error(`Cannot publish because file does not exist at '${zipFilePath}'`);
            }
            readStream = this.fsExtra.createReadStream(zipFilePath);
            //wait for the stream to open (no harm in doing this, and it helps solve an issue in the tests)
            await new Promise((resolve) => {
                readStream.on('open', resolve);
            });
            const route = (_b = (_a = options.packageUploadOverrides) === null || _a === void 0 ? void 0 : _a.route) !== null && _b !== void 0 ? _b : 'plugin_install';
            let requestOptions = this.generateBaseRequestOptions(route, options, {
                mysubmit: 'Replace',
                archive: readStream
            });
            //attach the remotedebug flag if configured
            if (options.remoteDebug) {
                requestOptions.formData.remotedebug = '1';
            }
            //attach the remotedebug_connect_early if present
            if (options.remoteDebugConnectEarly) {
                // eslint-disable-next-line camelcase
                requestOptions.formData.remotedebug_connect_early = '1';
            }
            //apply any supplied formData overrides
            for (const key in (_d = (_c = options.packageUploadOverrides) === null || _c === void 0 ? void 0 : _c.formData) !== null && _d !== void 0 ? _d : {}) {
                const value = options.packageUploadOverrides.formData[key];
                if (value === undefined || value === null) {
                    delete requestOptions.formData[key];
                }
                else {
                    requestOptions.formData[key] = value;
                }
            }
            //try to "replace" the channel first since that usually works.
            let response;
            try {
                response = await this.doPostRequest(requestOptions);
            }
            catch (replaceError) {
                //fail if this is a compile error
                if (this.isCompileError(replaceError.message) && options.failOnCompileError) {
                    throw new errors.CompileError('Compile error', replaceError, replaceError.results);
                }
                else {
                    requestOptions.formData.mysubmit = 'Install';
                    response = await this.doPostRequest(requestOptions);
                }
            }
            if (options.failOnCompileError) {
                if (this.isCompileError(response.body)) {
                    throw new errors.CompileError('Compile error', response, this.getRokuMessagesFromResponseBody(response.body));
                }
            }
            if (response.body.indexOf('Identical to previous version -- not replacing.') > -1) {
                return { message: 'Identical to previous version -- not replacing', results: response };
            }
            return { message: 'Successful deploy', results: response };
        }
        finally {
            //delete the zip file only if configured to do so
            if (options.retainDeploymentArchive === false) {
                await this.fsExtra.remove(zipFilePath);
            }
            //try to close the read stream to prevent files becoming locked
            try {
                readStream === null || readStream === void 0 ? void 0 : readStream.close();
            }
            catch (e) {
                this.logger.info('Error closing read stream', e);
            }
        }
    }
    /**
     * Does the response look like a compile error
     */
    isCompileError(responseHtml) {
        return !!/install\sfailure:\scompilation\sfailed/i.exec(responseHtml);
    }
    /**
     * Converts existing loaded package to squashfs for faster loading packages
     * @param options
     */
    async convertToSquashfs(options) {
        options = this.getOptions(options);
        if (!options.host) {
            throw new errors.MissingRequiredOptionError('must specify the host for the Roku device');
        }
        let requestOptions = this.generateBaseRequestOptions('plugin_install', options, {
            archive: '',
            mysubmit: 'Convert to squashfs'
        });
        let results;
        try {
            results = await this.doPostRequest(requestOptions);
        }
        catch (error) {
            //Occasionally this error is seen if the zip size and file name length at the
            //wrong combination. The device fails to respond to our request with a valid response.
            //The device successfully converted the zip, so ping the device and and check the response
            //for "fileType": "squashfs" then return a happy response, otherwise throw the original error
            if (error.code === 'HPE_INVALID_CONSTANT') {
                try {
                    results = await this.doPostRequest(requestOptions, false);
                    if (/"fileType"\s*:\s*"squashfs"/.test(results.body)) {
                        return results;
                    }
                }
                catch (e) {
                    throw error;
                }
            }
            else {
                throw error;
            }
        }
        if (results.body.indexOf('Conversion succeeded') === -1) {
            throw new errors.ConvertError('Squashfs conversion failed');
        }
    }
    /**
     * resign Roku Device with supplied pkg and
     * @param options
     */
    async rekeyDevice(options) {
        var _a;
        options = this.getOptions(options);
        if (!options.rekeySignedPackage) {
            throw new errors.MissingRequiredOptionError('Must supply rekeySignedPackage');
        }
        if (!options.signingPassword) {
            throw new errors.MissingRequiredOptionError('Must supply signingPassword');
        }
        let rekeySignedPackagePath = options.rekeySignedPackage;
        if (!path.isAbsolute(options.rekeySignedPackage)) {
            rekeySignedPackagePath = path.join(options.rootDir, options.rekeySignedPackage);
        }
        let requestOptions = this.generateBaseRequestOptions('plugin_inspect', options, {
            mysubmit: 'Rekey',
            passwd: options.signingPassword,
            archive: null
        });
        let results;
        try {
            requestOptions.formData.archive = this.fsExtra.createReadStream(rekeySignedPackagePath);
            results = await this.doPostRequest(requestOptions);
        }
        finally {
            //ensure the stream is closed
            try {
                (_a = requestOptions.formData.archive) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (_b) { }
        }
        let resultTextSearch = /<font color="red">([^<]+)<\/font>/.exec(results.body);
        if (!resultTextSearch) {
            throw new errors.UnparsableDeviceResponseError('Unknown Rekey Failure');
        }
        if (resultTextSearch[1] !== 'Success.') {
            throw new errors.FailedDeviceResponseError('Rekey Failure: ' + resultTextSearch[1]);
        }
        if (options.devId) {
            let devId = await this.getDevId(options);
            if (devId !== options.devId) {
                throw new errors.UnknownDeviceResponseError('Rekey was successful but resulting Dev ID "' + devId + '" did not match expected value of "' + options.devId + '"');
            }
        }
    }
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param options
     */
    async signExistingPackage(options) {
        options = this.getOptions(options);
        if (!options.signingPassword) {
            throw new errors.MissingRequiredOptionError('Must supply signingPassword');
        }
        let manifestPath = path.join(options.stagingDir, 'manifest');
        let parsedManifest = await this.parseManifest(manifestPath);
        let appName = parsedManifest.title + '/' + parsedManifest.major_version + '.' + parsedManifest.minor_version;
        let requestOptions = this.generateBaseRequestOptions('plugin_package', options, {
            mysubmit: 'Package',
            pkg_time: (new Date()).getTime(),
            passwd: options.signingPassword,
            app_name: appName //eslint-disable-line camelcase
        });
        let results = await this.doPostRequest(requestOptions);
        let failedSearchMatches = /<font.*>Failed: (.*)/.exec(results.body);
        if (failedSearchMatches) {
            throw new errors.FailedDeviceResponseError(failedSearchMatches[1], results);
        }
        let pkgSearchMatches = /<a href="(pkgs\/[^\.]+\.pkg)">/.exec(results.body);
        if (pkgSearchMatches) {
            return pkgSearchMatches[1];
        }
        throw new errors.UnknownDeviceResponseError('Unknown error signing package', results);
    }
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param pkgPath
     * @param options
     */
    async retrieveSignedPackage(pkgPath, options) {
        options = this.getOptions(options);
        let requestOptions = this.generateBaseRequestOptions(pkgPath, options);
        let pkgFilePath = this.getOutputPkgFilePath(options);
        return this.getToFile(requestOptions, pkgFilePath);
    }
    /**
     * Centralized function for handling POST http requests
     * @param params
     */
    async doPostRequest(params, verify = true) {
        let results = await new Promise((resolve, reject) => {
            request.post(params, (err, resp, body) => {
                if (err) {
                    return reject(err);
                }
                return resolve({ response: resp, body: body });
            });
        });
        if (verify) {
            this.checkRequest(results);
        }
        return results;
    }
    /**
     * Centralized function for handling GET http requests
     * @param params
     */
    async doGetRequest(params) {
        let results = await new Promise((resolve, reject) => {
            request.get(params, (err, resp, body) => {
                if (err) {
                    return reject(err);
                }
                return resolve({ response: resp, body: body });
            });
        });
        this.checkRequest(results);
        return results;
    }
    checkRequest(results) {
        var _a, _b, _c;
        if (!results || !results.response || typeof results.body !== 'string') {
            throw new errors.UnparsableDeviceResponseError('Invalid response', results);
        }
        if (results.response.statusCode === 401) {
            const host = (_c = (_b = (_a = results.response.request) === null || _a === void 0 ? void 0 : _a.host) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b);
            throw new errors.UnauthorizedDeviceResponseError(`Unauthorized. Please verify credentials for host '${host}'`, results);
        }
        let rokuMessages = this.getRokuMessagesFromResponseBody(results.body);
        if (rokuMessages.errors.length > 0) {
            throw new errors.FailedDeviceResponseError(rokuMessages.errors[0], rokuMessages);
        }
        if (results.response.statusCode !== 200) {
            throw new errors.InvalidDeviceResponseCodeError('Invalid response code: ' + results.response.statusCode, results);
        }
    }
    getRokuMessagesFromResponseBody(body) {
        const result = {
            errors: [],
            infos: [],
            successes: []
        };
        let errorRegex = /Shell\.create\('Roku\.Message'\)\.trigger\('[\w\s]+',\s+'(\w+)'\)\.trigger\('[\w\s]+',\s+'(.*?)'\)/igm;
        let match;
        while ((match = errorRegex.exec(body))) {
            let [, messageType, message] = match;
            switch (messageType.toLowerCase()) {
                case RokuMessageType.error:
                    if (!result.errors.includes(message)) {
                        result.errors.push(message);
                    }
                    break;
                case RokuMessageType.info:
                    if (!result.infos.includes(message)) {
                        result.infos.push(message);
                    }
                    break;
                case RokuMessageType.success:
                    if (!result.successes.includes(message)) {
                        result.successes.push(message);
                    }
                    break;
                default:
                    break;
            }
        }
        let jsonParseRegex = /JSON\.parse\(('.+')\);/igm;
        let jsonMatch;
        while ((jsonMatch = jsonParseRegex.exec(body))) {
            let [, jsonString] = jsonMatch;
            let jsonObject = (0, jsonc_parser_1.parse)(jsonString);
            if (typeof jsonObject === 'object' && !Array.isArray(jsonObject) && jsonObject !== null) {
                let messages = jsonObject.messages;
                if (!Array.isArray(messages)) {
                    continue;
                }
                for (let messageObject of messages) {
                    // Try to duck type the object to make sure it is some form of message to be displayed
                    if (typeof messageObject.type === 'string' && messageObject.text_type === 'text' && typeof messageObject.text === 'string') {
                        const messageType = messageObject.type;
                        const text = messageObject.text;
                        switch (messageType.toLowerCase()) {
                            case RokuMessageType.error:
                                if (!result.errors.includes(text)) {
                                    result.errors.push(text);
                                }
                                break;
                            case RokuMessageType.info:
                                if (!result.infos.includes(text)) {
                                    result.infos.push(text);
                                }
                                break;
                            case RokuMessageType.success:
                                if (!result.successes.includes(text)) {
                                    result.successes.push(text);
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        }
        return result;
    }
    /**
     * Create a zip of the project, and then publish to the target Roku device
     * @param options
     */
    async deploy(options, beforeZipCallback) {
        options = this.getOptions(options);
        await this.createPackage(options, beforeZipCallback);
        if (options.deleteInstalledChannel) {
            try {
                await this.deleteInstalledChannel(options);
            }
            catch (e) {
                // note we don't report the error; as we don't actually care that we could not deploy - it's just useless noise to log it.
            }
        }
        let result = await this.publish(options);
        return result;
    }
    /**
     * Deletes any installed dev channel on the target Roku device
     * @param options
     */
    async deleteInstalledChannel(options) {
        options = this.getOptions(options);
        let deleteOptions = this.generateBaseRequestOptions('plugin_install', options);
        deleteOptions.formData = {
            mysubmit: 'Delete',
            archive: ''
        };
        return this.doPostRequest(deleteOptions);
    }
    /**
     * Gets a screenshot from the device. A side-loaded channel must be running or an error will be thrown.
     */
    async takeScreenshot(options) {
        var _a, _b, _c;
        options.outDir = (_a = options.outDir) !== null && _a !== void 0 ? _a : this.screenshotDir;
        options.outFile = (_b = options.outFile) !== null && _b !== void 0 ? _b : `screenshot-${dayjs().format('YYYY-MM-DD-HH.mm.ss.SSS')}`;
        let saveFilePath;
        // Ask for the device to make an image
        let createScreenshotResult = await this.doPostRequest(Object.assign(Object.assign({}, this.generateBaseRequestOptions('plugin_inspect', options)), { formData: {
                mysubmit: 'Screenshot',
                archive: ''
            } }));
        // Pull the image url out of the response body
        const [_, imageUrlOnDevice, imageExt] = (_c = /["'](pkgs\/dev(\.jpg|\.png)\?.+?)['"]/gi.exec(createScreenshotResult.body)) !== null && _c !== void 0 ? _c : [];
        if (imageUrlOnDevice) {
            saveFilePath = util_1.util.standardizePath(path.join(options.outDir, options.outFile + imageExt));
            await this.getToFile(this.generateBaseRequestOptions(imageUrlOnDevice, options), saveFilePath);
        }
        else {
            throw new Error('No screen shot url returned from device');
        }
        return saveFilePath;
    }
    async getToFile(requestParams, filePath) {
        let writeStream;
        await this.fsExtra.ensureFile(filePath);
        return new Promise((resolve, reject) => {
            writeStream = this.fsExtra.createWriteStream(filePath, {
                flags: 'w'
            });
            if (!writeStream) {
                reject(new Error(`Unable to create write stream for "${filePath}"`));
                return;
            }
            //when the file has finished writing to disk, we can finally resolve and say we're done
            writeStream.on('finish', () => {
                resolve(filePath);
            });
            //if anything does wrong with the write stream, reject the promise
            writeStream.on('error', (error) => {
                reject(error);
            });
            request.get(requestParams).on('error', (err) => {
                reject(err);
            }).on('response', (response) => {
                if (response.statusCode !== 200) {
                    return reject(new Error('Invalid response code: ' + response.statusCode));
                }
            }).pipe(writeStream);
        }).finally(() => {
            try {
                writeStream.close();
            }
            catch (_a) { }
        });
    }
    /**
     * executes sames steps as deploy and signs the package and stores it in the out folder
     * @param options
     */
    async deployAndSignPackage(options, beforeZipCallback) {
        options = this.getOptions(options);
        let retainStagingDirInitialValue = options.retainStagingDir;
        options.retainStagingDir = true;
        await this.deploy(options, beforeZipCallback);
        if (options.convertToSquashfs) {
            await this.convertToSquashfs(options);
        }
        let remotePkgPath = await this.signExistingPackage(options);
        let localPkgFilePath = await this.retrieveSignedPackage(remotePkgPath, options);
        if (retainStagingDirInitialValue !== true) {
            await this.fsExtra.remove(options.stagingDir);
        }
        return localPkgFilePath;
    }
    /**
     * Get an options with all overridden vaues, and then defaults for missing values
     * @param options
     */
    getOptions(options = {}) {
        let fileOptions = {};
        const fileNames = ['rokudeploy.json', 'bsconfig.json'];
        if (options.project) {
            fileNames.unshift(options.project);
        }
        for (const fileName of fileNames) {
            if (this.fsExtra.existsSync(fileName)) {
                let configFileText = this.fsExtra.readFileSync(fileName).toString();
                let parseErrors = [];
                fileOptions = (0, jsonc_parser_1.parse)(configFileText, parseErrors, {
                    allowEmptyContent: true,
                    allowTrailingComma: true,
                    disallowComments: false
                });
                if (parseErrors.length > 0) {
                    throw new Error(`Error parsing "${path.resolve(fileName)}": ` + JSON.stringify(parseErrors.map(x => {
                        return {
                            message: (0, jsonc_parser_1.printParseErrorCode)(x.error),
                            offset: x.offset,
                            length: x.length
                        };
                    })));
                }
                break;
            }
        }
        let defaultOptions = {
            outDir: './out',
            outFile: 'roku-deploy',
            retainDeploymentArchive: true,
            incrementBuildNumber: false,
            failOnCompileError: true,
            deleteInstalledChannel: true,
            packagePort: 80,
            remotePort: 8060,
            timeout: 150000,
            rootDir: './',
            files: [...exports.DefaultFiles],
            username: 'rokudev',
            logLevel: Logger_1.LogLevel.log
        };
        //override the defaults with any found or provided options
        let finalOptions = Object.assign(Object.assign(Object.assign({}, defaultOptions), fileOptions), options);
        this.logger.logLevel = finalOptions.logLevel;
        //fully resolve the folder paths
        finalOptions.rootDir = path.resolve(process.cwd(), finalOptions.rootDir);
        finalOptions.outDir = path.resolve(process.cwd(), finalOptions.outDir);
        finalOptions.retainStagingDir = (finalOptions.retainStagingDir !== undefined) ? finalOptions.retainStagingDir : finalOptions.retainStagingFolder;
        //sync the new option with the old one (for back-compat)
        finalOptions.retainStagingFolder = finalOptions.retainStagingDir;
        let stagingDir = finalOptions.stagingDir || finalOptions.stagingFolderPath;
        //stagingDir
        if (stagingDir) {
            finalOptions.stagingDir = path.resolve(process.cwd(), stagingDir);
        }
        else {
            finalOptions.stagingDir = path.resolve(process.cwd(), util_1.util.standardizePath(`${finalOptions.outDir}/.roku-deploy-staging`));
        }
        //sync the new option with the old one (for back-compat)
        finalOptions.stagingFolderPath = finalOptions.stagingDir;
        return finalOptions;
    }
    /**
     * Centralizes getting output zip file path based on passed in options
     * @param options
     */
    getOutputZipFilePath(options) {
        options = this.getOptions(options);
        let zipFileName = options.outFile;
        if (!zipFileName.toLowerCase().endsWith('.zip') && !zipFileName.toLowerCase().endsWith('.squashfs')) {
            zipFileName += '.zip';
        }
        let outFolderPath = path.resolve(options.outDir);
        let outZipFilePath = path.join(outFolderPath, zipFileName);
        return outZipFilePath;
    }
    /**
     * Centralizes getting output pkg file path based on passed in options
     * @param options
     */
    getOutputPkgFilePath(options) {
        options = this.getOptions(options);
        let pkgFileName = options.outFile;
        if (pkgFileName.toLowerCase().endsWith('.zip')) {
            pkgFileName = pkgFileName.replace('.zip', '.pkg');
        }
        else {
            pkgFileName += '.pkg';
        }
        let outFolderPath = path.resolve(options.outDir);
        let outPkgFilePath = path.join(outFolderPath, pkgFileName);
        return outPkgFilePath;
    }
    async getDeviceInfo(options) {
        options = this.getOptions(options);
        //if the host is a DNS name, look up the IP address
        try {
            options.host = await util_1.util.dnsLookup(options.host);
        }
        catch (e) {
            //try using the host as-is (it'll probably fail...)
        }
        const url = `http://${options.host}:${options.remotePort}/query/device-info`;
        let response = await this.doGetRequest({
            url: url,
            timeout: options.timeout,
            headers: {
                'User-Agent': 'https://github.com/RokuCommunity/roku-deploy'
            }
        });
        try {
            const parsedContent = await xml2js.parseStringPromise(response.body, {
                explicitArray: false
            });
            // clone the data onto an object because xml2js somehow makes this object not an object???
            let deviceInfo = Object.assign({}, parsedContent['device-info']);
            if (options.enhance) {
                const result = {};
                // sanitize/normalize values to their native formats, and also convert property names to camelCase
                for (let key in deviceInfo) {
                    result[lodash.camelCase(key)] = this.normalizeDeviceInfoFieldValue(deviceInfo[key]);
                }
                deviceInfo = result;
            }
            return deviceInfo;
        }
        catch (e) {
            throw new errors.UnparsableDeviceResponseError('Could not retrieve device info', response);
        }
    }
    /**
     * Normalize a deviceInfo field value. This includes things like converting boolean strings to booleans, number strings to numbers,
     * decoding HtmlEntities, etc.
     * @param deviceInfo
     */
    normalizeDeviceInfoFieldValue(value) {
        let num;
        // convert 'true' and 'false' string values to boolean
        if (value === 'true') {
            return true;
        }
        else if (value === 'false') {
            return false;
        }
        else if (value.trim() !== '' && !isNaN(num = Number(value))) {
            return num;
        }
        else {
            return util_1.util.decodeHtmlEntities(value);
        }
    }
    async getDevId(options) {
        const deviceInfo = await this.getDeviceInfo(options);
        return deviceInfo['keyed-developer-id'];
    }
    async parseManifest(manifestPath) {
        if (!await this.fsExtra.pathExists(manifestPath)) {
            throw new Error(manifestPath + ' does not exist');
        }
        let manifestContents = await this.fsExtra.readFile(manifestPath, 'utf-8');
        return this.parseManifestFromString(manifestContents);
    }
    parseManifestFromString(manifestContents) {
        let manifestLines = manifestContents.split('\n');
        let manifestData = {};
        manifestData.keyIndexes = {};
        manifestData.lineCount = manifestLines.length;
        manifestLines.forEach((line, index) => {
            let match = /(\w+)=(.+)/.exec(line);
            if (match) {
                let key = match[1];
                manifestData[key] = match[2];
                manifestData.keyIndexes[key] = index;
            }
        });
        return manifestData;
    }
    stringifyManifest(manifestData) {
        let output = [];
        if (manifestData.keyIndexes && manifestData.lineCount) {
            output.fill('', 0, manifestData.lineCount);
            let key;
            for (key in manifestData) {
                if (key === 'lineCount' || key === 'keyIndexes') {
                    continue;
                }
                let index = manifestData.keyIndexes[key];
                output[index] = `${key}=${manifestData[key]}`;
            }
        }
        else {
            output = Object.keys(manifestData).map((key) => {
                return `${key}=${manifestData[key]}`;
            });
        }
        return output.join('\n');
    }
    /**
     * Given a path to a folder, zip up that folder and all of its contents
     * @param srcFolder the folder that should be zipped
     * @param zipFilePath the path to the zip that will be created
     * @param preZipCallback a function to call right before every file gets added to the zip
     * @param files a files array used to filter the files from `srcFolder`
     */
    async zipFolder(srcFolder, zipFilePath, preFileZipCallback, files = ['**/*']) {
        const filePaths = await this.getFilePaths(files, srcFolder);
        const zip = new JSZip();
        // Allows us to wait until all are done before we build the zip
        const promises = [];
        for (const file of filePaths) {
            const promise = this.fsExtra.readFile(file.src).then((data) => {
                if (preFileZipCallback) {
                    data = preFileZipCallback(file, data);
                }
                const ext = path.extname(file.dest).toLowerCase();
                let compression = 'DEFLATE';
                if (ext === '.jpg' || ext === '.png' || ext === '.jpeg') {
                    compression = 'STORE';
                }
                zip.file(file.dest.replace(/[\\/]/g, '/'), data, {
                    compression: compression
                });
            });
            promises.push(promise);
        }
        await Promise.all(promises);
        // level 2 compression seems to be the best balance between speed and file size. Speed matters more since most will be calling squashfs afterwards.
        const content = await zip.generateAsync({ type: 'nodebuffer', compressionOptions: { level: 2 } });
        return this.fsExtra.outputFile(zipFilePath, content);
    }
}
exports.RokuDeploy = RokuDeploy;
var RokuMessageType;
(function (RokuMessageType) {
    RokuMessageType["success"] = "success";
    RokuMessageType["info"] = "info";
    RokuMessageType["error"] = "error";
})(RokuMessageType || (RokuMessageType = {}));
exports.DefaultFiles = [
    'source/**/*.*',
    'components/**/*.*',
    'images/**/*.*',
    'manifest'
];
//# sourceMappingURL=RokuDeploy.js.map