/// <reference types="node" />
import * as _fsExtra from 'fs-extra';
import type { RokuDeployOptions, FileEntry } from './RokuDeployOptions';
import { LogLevel } from './Logger';
export declare class RokuDeploy {
    constructor();
    private logger;
    fsExtra: typeof _fsExtra;
    screenshotDir: string;
    /**
     * Copies all of the referenced files to the staging folder
     * @param options
     */
    prepublishToStaging(options: RokuDeployOptions): Promise<string>;
    /**
     * Given an array of `FilesType`, normalize them each into a `StandardizedFileEntry`.
     * Each entry in the array or inner `src` array will be extracted out into its own object.
     * This makes it easier to reason about later on in the process.
     * @param files
     */
    normalizeFilesArray(files: FileEntry[]): (string | StandardizedFileEntry)[];
    /**
     * Given an already-populated staging folder, create a zip archive of it and copy it to the output folder
     * @param options
     */
    zipPackage(options: RokuDeployOptions): Promise<void>;
    /**
     * Create a zip folder containing all of the specified roku project files.
     * @param options
     */
    createPackage(options: RokuDeployOptions, beforeZipCallback?: (info: BeforeZipCallbackInfo) => Promise<void> | void): Promise<void>;
    /**
     * Given a root directory, normalize it to a full path.
     * Fall back to cwd if not specified
     * @param rootDir
     */
    normalizeRootDir(rootDir: string): string;
    /**
    * Get all file paths for the specified options
    * @param files
    * @param rootFolderPath - the absolute path to the root dir where relative files entries are relative to
    */
    getFilePaths(files: FileEntry[], rootDir: string): Promise<StandardizedFileEntry[]>;
    /**
     * Given a full path to a file, determine its dest path
     * @param srcPath the absolute path to the file. This MUST be a file path, and it is not verified to exist on the filesystem
     * @param files the files array
     * @param rootDir the absolute path to the root dir
     * @param skipMatch - skip running the minimatch process (i.e. assume the file is a match
     * @returns the RELATIVE path to the dest location for the file.
     */
    getDestPath(srcPathAbsolute: string, files: FileEntry[], rootDir: string, skipMatch?: boolean): string;
    /**
     * Compute the `dest` path. This accounts for magic globstars in the pattern,
     * as well as relative paths based on the dest. This is only used internally.
     * @param src an absolute, normalized path for a file
     * @param dest the `dest` entry for this file. If omitted, files will derive their paths relative to rootDir.
     * @param pattern the glob pattern originally used to find this file
     * @param rootDir absolute normalized path to the rootDir
     */
    private computeFileDestPath;
    /**
     * Copy all of the files to the staging directory
     * @param fileGlobs
     * @param stagingPath
     */
    private copyToStaging;
    private generateBaseRequestOptions;
    /**
     * Simulate pressing the home button on the remote for this roku.
     * This makes the roku return to the home screen
     * @param host - the host
     * @param port - the port that should be used for the request. defaults to 8060
     * @param timeout - request timeout duration in milliseconds. defaults to 150000
     */
    pressHomeButton(host: any, port?: number, timeout?: number): Promise<HttpResponse>;
    /**
     * Publish a pre-existing packaged zip file to a remote Roku.
     * @param options
     */
    publish(options: RokuDeployOptions): Promise<{
        message: string;
        results: any;
    }>;
    /**
     * Does the response look like a compile error
     */
    private isCompileError;
    /**
     * Converts existing loaded package to squashfs for faster loading packages
     * @param options
     */
    convertToSquashfs(options: RokuDeployOptions): Promise<void>;
    /**
     * resign Roku Device with supplied pkg and
     * @param options
     */
    rekeyDevice(options: RokuDeployOptions): Promise<void>;
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param options
     */
    signExistingPackage(options: RokuDeployOptions): Promise<string>;
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param pkgPath
     * @param options
     */
    retrieveSignedPackage(pkgPath: string, options: RokuDeployOptions): Promise<string>;
    /**
     * Centralized function for handling POST http requests
     * @param params
     */
    private doPostRequest;
    /**
     * Centralized function for handling GET http requests
     * @param params
     */
    private doGetRequest;
    private checkRequest;
    private getRokuMessagesFromResponseBody;
    /**
     * Create a zip of the project, and then publish to the target Roku device
     * @param options
     */
    deploy(options?: RokuDeployOptions, beforeZipCallback?: (info: BeforeZipCallbackInfo) => void): Promise<{
        message: string;
        results: any;
    }>;
    /**
     * Deletes any installed dev channel on the target Roku device
     * @param options
     */
    deleteInstalledChannel(options?: RokuDeployOptions): Promise<HttpResponse>;
    /**
     * Gets a screenshot from the device. A side-loaded channel must be running or an error will be thrown.
     */
    takeScreenshot(options: TakeScreenshotOptions): Promise<string>;
    private getToFile;
    /**
     * executes sames steps as deploy and signs the package and stores it in the out folder
     * @param options
     */
    deployAndSignPackage(options?: RokuDeployOptions, beforeZipCallback?: (info: BeforeZipCallbackInfo) => void): Promise<string>;
    /**
     * Get an options with all overridden vaues, and then defaults for missing values
     * @param options
     */
    getOptions(options?: RokuDeployOptions): {
        project?: string;
        outDir?: string;
        outFile?: string;
        rootDir?: string;
        files?: FileEntry[];
        retainStagingFolder?: boolean;
        retainStagingDir?: boolean;
        retainDeploymentArchive?: boolean;
        stagingFolderPath?: string;
        stagingDir?: string;
        host?: string;
        packagePort?: number;
        remoteDebug?: boolean;
        remoteDebugConnectEarly?: boolean;
        remotePort?: number;
        timeout?: number;
        username?: string;
        password?: string;
        signingPassword?: string;
        rekeySignedPackage?: string;
        devId?: string;
        incrementBuildNumber?: boolean;
        convertToSquashfs?: boolean;
        failOnCompileError?: boolean;
        logLevel?: LogLevel;
        deleteInstalledChannel?: boolean;
    };
    /**
     * Centralizes getting output zip file path based on passed in options
     * @param options
     */
    getOutputZipFilePath(options: RokuDeployOptions): string;
    /**
     * Centralizes getting output pkg file path based on passed in options
     * @param options
     */
    getOutputPkgFilePath(options?: RokuDeployOptions): string;
    getDeviceInfo(options?: RokuDeployOptions): Promise<any>;
    getDevId(options?: RokuDeployOptions): Promise<any>;
    parseManifest(manifestPath: string): Promise<ManifestData>;
    parseManifestFromString(manifestContents: string): ManifestData;
    stringifyManifest(manifestData: ManifestData): string;
    /**
     * Given a path to a folder, zip up that folder and all of its contents
     * @param srcFolder the folder that should be zipped
     * @param zipFilePath the path to the zip that will be created
     * @param preZipCallback a function to call right before every file gets added to the zip
     * @param files a files array used to filter the files from `srcFolder`
     */
    zipFolder(srcFolder: string, zipFilePath: string, preFileZipCallback?: (file: StandardizedFileEntry, data: Buffer) => Buffer, files?: FileEntry[]): Promise<void>;
}
export interface ManifestData {
    [key: string]: any;
    keyIndexes?: Record<string, number>;
    lineCount?: number;
}
export interface BeforeZipCallbackInfo {
    /**
     * Contains an associative array of the parsed values in the manifest
     */
    manifestData: ManifestData;
    /**
     * @deprecated since 3.9.0. use `stagingDir` instead
     */
    stagingFolderPath: string;
    /**
     * The directory where the files were staged
     */
    stagingDir: string;
}
export interface StandardizedFileEntry {
    /**
     * The full path to the source file
     */
    src: string;
    /**
     * The path relative to the root of the pkg to where the file should be placed
     */
    dest: string;
}
export interface RokuMessages {
    errors: string[];
    infos: string[];
    successes: string[];
}
export declare const DefaultFiles: string[];
export interface HttpResponse {
    response: any;
    body: any;
}
export interface TakeScreenshotOptions {
    /**
     * The IP address or hostname of the target Roku device.
     * @example '192.168.1.21'
     */
    host: string;
    /**
     * The password for logging in to the developer portal on the target Roku device
     */
    password: string;
    /**
     * A full path to the folder where the screenshots should be saved.
     * Will use the OS temp directory by default
     */
    outDir?: string;
    /**
     * The base filename the image file should be given (excluding the extension)
     * The default format looks something like this: screenshot-YYYY-MM-DD-HH.mm.ss.SSS.<jpg|png>
     */
    outFile?: string;
}
