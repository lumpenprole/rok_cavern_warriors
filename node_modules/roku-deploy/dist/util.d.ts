export declare class Util {
    /**
     * Determine if `childPath` is contained within the `parentPath`
     * @param parentPath
     * @param childPath
     * @param standardizePaths if false, the paths are assumed to already be in the same format and are not re-standardized
     */
    isParentOfPath(parentPath: string, childPath: string, standardizePaths?: boolean): boolean;
    /**
     * Determines if the given path is a file
     * @param filePathAbsolute
     */
    isFile(filePathAbsolute: string): Promise<boolean>;
    /**
     * Normalize path and replace all directory separators with current OS separators
     * @param thePath
     */
    standardizePath(thePath: string): string;
    /**
     * Convert all slashes to forward slashes
     */
    toForwardSlashes(thePath: string): string;
    /**
     * Do a case-insensitive string replacement
     * @param subject the string that will have its contents replaced
     * @param search the search text to find in `subject`
     * @param replace the text to replace `search` with in `subject`
     */
    stringReplaceInsensitive(subject: string, search: string, replace: string): string;
    /**
     * Keep calling the callback until it does NOT throw an exception, or until the max number of tries has been reached.
     * @param callback
     * @param maxTries
     * @param sleepMilliseconds
     */
    tryRepeatAsync<T>(callback: any, maxTries?: number, sleepMilliseconds?: number): Promise<T>;
    sleep(milliseconds: number): Promise<void>;
    /**
     * Determine if a file exists (case insensitive)
     */
    fileExistsCaseInsensitive(filePath: string): Promise<boolean>;
    /**
     * Run a series of glob patterns, returning the matches in buckets corresponding to their pattern index.
     */
    globAllByIndex(patterns: string[], cwd: string): Promise<string[][]>;
    /**
     * Filter all of the matches based on a minimatch pattern
     * @param stopIndex the max index of `matchesByIndex` to filter until
     * @param pattern - the pattern used to filter out entries from `matchesByIndex`. Usually preceeded by a `!`
     */
    private filterPaths;
}
export declare let util: Util;
/**
 * A tagged template literal function for standardizing the path.
 */
export declare function standardizePath(stringParts: any, ...expressions: any[]): string;
