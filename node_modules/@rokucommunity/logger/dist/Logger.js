"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLevelColor = exports.LogLevelNumeric = exports.LogLevelPriority = exports.Logger = exports.chalk = void 0;
const safeJsonStringify = require("safe-json-stringify");
const serialize_error_1 = require("serialize-error");
const date_fns_1 = require("date-fns");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const Chalk = require("chalk");
const Stopwatch_1 = require("./Stopwatch");
//export our instance of chalk for use in unit tests
exports.chalk = new Chalk.Instance({ level: 3 });
class Logger {
    constructor(options) {
        this.options = this.sanitizeOptions(options);
    }
    /**
     * The timestamp format string. Defaults to 'HH:mm:ss.SSS' (24-hour time with milliseconds)
     *
     * https://date-fns.org/v2.30.0/docs/format
     */
    get timestampFormat() {
        var _a, _b, _c;
        return (_c = (_a = this.options.timestampFormat) !== null && _a !== void 0 ? _a : (_b = this.options.parent) === null || _b === void 0 ? void 0 : _b.timestampFormat) !== null && _c !== void 0 ? _c : 'HH:mm:ss.SSS';
    }
    set timestampFormat(value) {
        this.options.timestampFormat = value;
    }
    /**
     * The log level of this logger. If a log level is not specified, it will inherit from the parent logger or default to 'log'
     */
    get logLevel() {
        var _a, _b, _c;
        return (_c = (_a = this.options.logLevel) !== null && _a !== void 0 ? _a : (_b = this.options.parent) === null || _b === void 0 ? void 0 : _b.logLevel) !== null && _c !== void 0 ? _c : 'log';
    }
    set logLevel(value) {
        this.options.logLevel = typeof value === 'number' ? this.getLogLevelNumeric(value) : this.getLogLevelText(value);
    }
    /**
     * Given a LogLevel number or string, return the string representation of the LogLevel
     */
    getLogLevelText(logLevel) {
        if (typeof logLevel === 'number') {
            return LogLevelNumeric[logLevel];
        }
        return logLevel;
    }
    /**
     * Given a LogLevel number or string, return the string representation of the LogLevel
     */
    getLogLevelNumeric(logLevel) {
        if (typeof logLevel === 'string') {
            return LogLevelNumeric[logLevel];
        }
        return logLevel;
    }
    /**
     * Get the prefix of this logger and all its parents
     */
    getPrefixes() {
        var _a, _b;
        const prefixes = (_b = (_a = this.options.parent) === null || _a === void 0 ? void 0 : _a.getPrefixes()) !== null && _b !== void 0 ? _b : [];
        if (this.options.prefix) {
            prefixes.push(this.options.prefix);
        }
        return prefixes;
    }
    /**
     * The prefix for the current logger only. This excludes prefixes inherited from parent loggers.
     */
    get prefix() {
        return this.options.prefix;
    }
    set prefix(value) {
        this.options.prefix = value;
    }
    get parent() {
        return this.options.parent;
    }
    set parent(value) {
        this.options.parent = value;
    }
    get transports() {
        return this.options.transports;
    }
    set transports(value) {
        this.options.transports = value;
    }
    /**
     * If true, colors will be used in transports that support it.
     */
    get enableColor() {
        var _a, _b, _c;
        return (_c = (_a = this.options.enableColor) !== null && _a !== void 0 ? _a : (_b = this.options.parent) === null || _b === void 0 ? void 0 : _b.enableColor) !== null && _c !== void 0 ? _c : true;
    }
    set enableColor(value) {
        this.options.enableColor = value;
    }
    /**
     * Get colored text if color is enabled, or the raw text back if color is not enabled
     */
    colorWrap(text, color, enableColor = this.enableColor) {
        if (enableColor) {
            return exports.chalk[color](text);
        }
        else {
            return text;
        }
    }
    /**
     * Wrap the text in the color of the given logLevel
     */
    logLevelColorWrap(text, logLevel, enableColor = this.enableColor) {
        var _a;
        if (enableColor) {
            const logColorFn = (_a = exports.LogLevelColor[logLevel]) !== null && _a !== void 0 ? _a : exports.LogLevelColor.log;
            return logColorFn(text);
        }
        else {
            return text;
        }
    }
    /**
     * Should the log level be padded with trailing spaces when printed
     */
    get consistentLogLevelWidth() {
        var _a, _b, _c;
        return (_c = (_a = this.options.consistentLogLevelWidth) !== null && _a !== void 0 ? _a : (_b = this.options.parent) === null || _b === void 0 ? void 0 : _b.consistentLogLevelWidth) !== null && _c !== void 0 ? _c : false;
    }
    set consistentLogLevelWidth(value) {
        this.options.consistentLogLevelWidth = value;
    }
    /**
     * Should the log level be padded with trailing spaces when printed
     */
    get printLogLevel() {
        var _a, _b, _c;
        return (_c = (_a = this.options.printLogLevel) !== null && _a !== void 0 ? _a : (_b = this.options.parent) === null || _b === void 0 ? void 0 : _b.printLogLevel) !== null && _c !== void 0 ? _c : true;
    }
    set printLogLevel(value) {
        this.options.printLogLevel = value;
    }
    /**
    * Get notified about every log message
    * @param subscriber a function that is called with the given log message
    * @returns an unsubscribe function
    */
    subscribe(subscriber) {
        return this.addTransport({
            pipe: subscriber
        });
    }
    /**
     * Register a transport handler to be notified of all log events
     */
    addTransport(transport) {
        this.options.transports.push(transport);
        return () => {
            this.removeTransport(transport);
        };
    }
    /**
     * Remove a transport from this logger instance (but not parents
     */
    removeTransport(transport) {
        const index = this.options.transports.indexOf(transport);
        if (index > -1) {
            this.options.transports.splice(index, 1);
        }
    }
    emit(message) {
        var _a, _b;
        for (const transport of (_a = this.options.transports) !== null && _a !== void 0 ? _a : []) {
            transport.pipe(message);
        }
        //emit to parent as well
        (_b = this.options.parent) === null || _b === void 0 ? void 0 : _b.emit(message);
    }
    formatTimestamp(date) {
        return (0, date_fns_1.format)(date, this.timestampFormat);
    }
    /**
     * Get the current date. Mostly here to allow mocking for unit tests
     */
    getCurrentDate() {
        return new Date();
    }
    /**
     * Given an array of args, stringify them
     */
    stringifyArgs(args) {
        let argsText = '';
        for (let i = 0; i < args.length; i++) {
            let arg = args[i];
            //separate args with a space
            if (i > 0) {
                argsText += ' ';
            }
            const argType = typeof arg;
            switch (argType) {
                case 'string':
                    argsText += arg;
                    break;
                case 'undefined':
                    argsText += 'undefined';
                    break;
                case 'object':
                    if (toString.call(arg) === '[object RegExp]') {
                        argsText += arg.toString();
                    }
                    else {
                        argsText += safeJsonStringify((0, serialize_error_1.serializeError)(arg), (_, value) => {
                            return typeof value === 'bigint' ? value.toString() : value;
                        });
                    }
                    break;
                default:
                    argsText += arg.toString();
                    break;
            }
        }
        return argsText;
    }
    /**
     * Get all the leading parts of the message. This includes timestamp, log level, any message prefixes.
     * This excludes actual body of the messages.
     */
    formatLeadingMessageParts(message, enableColor = this.enableColor) {
        let timestampText = message.timestamp;
        let logLevelText = message.logLevel.toUpperCase();
        if (this.consistentLogLevelWidth) {
            logLevelText = logLevelText.padEnd(5, ' ');
        }
        let result = '[' + this.colorWrap(timestampText, 'grey', enableColor) + ']';
        if (this.printLogLevel) {
            result += '[' + this.logLevelColorWrap(logLevelText, message.logLevel, enableColor) + ']';
        }
        const prefix = message.prefixes.join('');
        //separate the datestamp from the prefix with a space
        if (prefix.length > 0) {
            result += ' ' + prefix;
        }
        return result;
    }
    /**
     * Build a single string from the LogMessage in the Logger-standard format
     */
    formatMessage(message, enableColor = false) {
        return this.formatLeadingMessageParts(message, enableColor) + ' ' + message.argsText;
    }
    /**
     * The base logging function. Provide a level
     */
    buildLogMessage(logLevel, ...args) {
        const date = this.getCurrentDate();
        const timestamp = this.formatTimestamp(date);
        return {
            date: date,
            timestamp: timestamp,
            prefixes: this.getPrefixes(),
            logLevel: this.getLogLevelText(logLevel),
            args: args,
            argsText: this.stringifyArgs(args),
            logger: this
        };
    }
    /**
     * Determine if the specified logLevel is currently active.
     */
    isLogLevelEnabled(targetLogLevel) {
        var _a;
        const lowerTargetLogLevel = this.getLogLevelText(targetLogLevel);
        const incomingPriority = (_a = exports.LogLevelPriority[lowerTargetLogLevel]) !== null && _a !== void 0 ? _a : exports.LogLevelPriority.log;
        const currentLogLevel = this.getLogLevelText(this.logLevel);
        return exports.LogLevelPriority[currentLogLevel] >= incomingPriority;
    }
    /**
     * Write a log entry IF the specified logLevel is enabled
     */
    write(logLevel, ...args) {
        if (this.isLogLevelEnabled(logLevel)) {
            const message = this.buildLogMessage(logLevel, ...args);
            this.emit(message);
        }
    }
    trace(...messages) {
        this.write('trace', ...messages);
    }
    debug(...messages) {
        this.write('debug', ...messages);
    }
    info(...messages) {
        this.write('info', ...messages);
    }
    log(...messages) {
        this.write('log', ...messages);
    }
    warn(...messages) {
        this.write('warn', ...messages);
    }
    error(...messages) {
        this.write('error', ...messages);
    }
    /**
     * Writes to the log (if logLevel matches), and also provides a function that can be called to mark the end of a time.
     */
    timeStart(logLevel, ...messages) {
        //call the log if loglevel is in range
        if (this.isLogLevelEnabled(logLevel)) {
            const stopwatch = new Stopwatch_1.Stopwatch();
            //write the initial log
            this.write(logLevel, ...messages);
            stopwatch.start();
            return (status = 'finished') => {
                stopwatch.stop();
                this.write(logLevel, ...messages, `${status}. (${this.colorWrap(stopwatch.getDurationText(), 'blue')})`);
            };
        }
        return noop;
    }
    /**
     * Writes to the log (if logLevel matches), and also times how long the action took to occur.
     * `action` is called regardless of logLevel, so this function can be used to nicely wrap
     * pieces of functionality.
     * The action function also includes two parameters, `pause` and `resume`, which can be used to improve timings by focusing only on
     * the actual logic of that action.
     */
    time(logLevel, messages, action) {
        //call the log if loglevel is in range
        if (this.isLogLevelEnabled(logLevel)) {
            const stopwatch = new Stopwatch_1.Stopwatch();
            messages = Array.isArray(messages) ? messages : [messages];
            //write the initial log
            this.write(logLevel, ...messages);
            stopwatch.start();
            //execute the action
            const result = action(stopwatch.stop.bind(stopwatch), stopwatch.start.bind(stopwatch));
            //return a function to call when the timer is complete
            const done = () => {
                stopwatch.stop();
                this.write(logLevel, ...messages, `finished. (${this.colorWrap(stopwatch.getDurationText(), 'blue')})`);
            };
            //if this is a promise, wait for it to resolve and then return the original result
            if (typeof (result === null || result === void 0 ? void 0 : result.then) === 'function') {
                return Promise.resolve(result).then(done).then(() => {
                    return result;
                });
            }
            else {
                //this was not a promise. finish the timer now
                done();
                return result;
            }
        }
        else {
            return action(noop, noop);
        }
    }
    createLogger(param) {
        const options = typeof param === 'string' ? { prefix: param } : param;
        return new Logger(Object.assign(Object.assign({}, options !== null && options !== void 0 ? options : {}), { parent: this }));
    }
    useLogger(param, callback) {
        const logger = this.createLogger(param); //typecast as string (to tell typescript to chill out)
        return callback(logger);
    }
    /**
     * Ensure we have a stable set of options.
     * @param options
     * @returns
     */
    sanitizeOptions(param) {
        var _a;
        const options = typeof param === 'string' ? { prefix: param } : param;
        const result = Object.assign({ transports: [], prefix: undefined }, options !== null && options !== void 0 ? options : {});
        if (typeof result.logLevel === 'number') {
            result.logLevel = LogLevelNumeric[result.logLevel];
        }
        result.logLevel = (_a = result.logLevel) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        return result;
    }
    destroy() {
        var _a, _b, _c;
        for (const transport of (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.transports) !== null && _b !== void 0 ? _b : []) {
            (_c = transport === null || transport === void 0 ? void 0 : transport.destroy) === null || _c === void 0 ? void 0 : _c.call(transport);
        }
        if (this.options) {
            this.options.transports = [];
            this.options.parent = undefined;
        }
    }
}
exports.Logger = Logger;
exports.LogLevelPriority = {
    off: 0,
    error: 1,
    warn: 2,
    log: 3,
    info: 4,
    debug: 5,
    trace: 6
};
var LogLevelNumeric;
(function (LogLevelNumeric) {
    LogLevelNumeric[LogLevelNumeric["off"] = 0] = "off";
    LogLevelNumeric[LogLevelNumeric["error"] = 1] = "error";
    LogLevelNumeric[LogLevelNumeric["warn"] = 2] = "warn";
    LogLevelNumeric[LogLevelNumeric["log"] = 3] = "log";
    LogLevelNumeric[LogLevelNumeric["info"] = 4] = "info";
    LogLevelNumeric[LogLevelNumeric["debug"] = 5] = "debug";
    LogLevelNumeric[LogLevelNumeric["trace"] = 6] = "trace";
})(LogLevelNumeric = exports.LogLevelNumeric || (exports.LogLevelNumeric = {}));
exports.LogLevelColor = {
    off: x => x,
    error: exports.chalk.red,
    warn: exports.chalk.yellow,
    log: x => x,
    info: exports.chalk.green,
    debug: exports.chalk.blue,
    trace: exports.chalk.magenta
};
/**
 * Empty function that does nothing
 */
function noop() {
}
//# sourceMappingURL=Logger.js.map